"""
DAG Schemas for Workflow Management

Pydantic models for workflow plans that can be:
- Generated by LLM
- Executed by DAGExecutor
- Visualized by React Flow on frontend
"""

from pydantic import BaseModel, Field
from typing import List, Dict, Any, Optional
from enum import Enum
from datetime import datetime


class TaskStatus(str, Enum):
    """Status of a task in the workflow"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


class TaskPriority(str, Enum):
    """Priority levels for tasks"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"


class TaskNode(BaseModel):
    """A single task in the workflow DAG"""
    id: str = Field(..., description="Unique task identifier")
    agent: str = Field(..., description="Agent responsible for this task")
    instruction: str = Field(..., description="What the agent should do")
    dependencies: List[str] = Field(default_factory=list, description="IDs of prerequisite tasks")
    priority: TaskPriority = TaskPriority.MEDIUM
    estimated_duration: int = Field(default=30, description="Estimated seconds to complete")
    status: TaskStatus = TaskStatus.PENDING
    result: Optional[str] = None
    error: Optional[str] = None
    started_at: Optional[str] = None
    completed_at: Optional[str] = None
    
    def start(self):
        """Mark task as running"""
        self.status = TaskStatus.RUNNING
        self.started_at = datetime.utcnow().isoformat()
    
    def complete(self, result: str):
        """Mark task as completed"""
        self.status = TaskStatus.COMPLETED
        self.result = result
        self.completed_at = datetime.utcnow().isoformat()
    
    def fail(self, error: str):
        """Mark task as failed"""
        self.status = TaskStatus.FAILED
        self.error = error
        self.completed_at = datetime.utcnow().isoformat()


class WorkflowPlan(BaseModel):
    """Complete workflow plan (DAG)"""
    id: str = Field(..., description="Workflow ID")
    objective: str = Field(..., description="What we're trying to accomplish")
    nodes: List[TaskNode] = Field(..., description="Tasks in the workflow")
    created_at: str = Field(default_factory=lambda: datetime.utcnow().isoformat())
    status: TaskStatus = TaskStatus.PENDING
    
    def get_ready_tasks(self) -> List[TaskNode]:
        """
        Get tasks that are ready to execute.
        A task is ready if all its dependencies are completed.
        """
        completed_ids = {
            n.id for n in self.nodes 
            if n.status == TaskStatus.COMPLETED
        }
        
        ready = []
        for node in self.nodes:
            if node.status == TaskStatus.PENDING:
                if all(dep in completed_ids for dep in node.dependencies):
                    ready.append(node)
        
        return ready
    
    def get_running_tasks(self) -> List[TaskNode]:
        """Get currently running tasks"""
        return [n for n in self.nodes if n.status == TaskStatus.RUNNING]
    
    def get_pending_tasks(self) -> List[TaskNode]:
        """Get pending tasks"""
        return [n for n in self.nodes if n.status == TaskStatus.PENDING]
    
    def is_complete(self) -> bool:
        """Check if all tasks are done (completed or failed)"""
        return all(
            n.status in [TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.SKIPPED]
            for n in self.nodes
        )
    
    def get_completion_percentage(self) -> float:
        """Get percentage of completed tasks"""
        if not self.nodes:
            return 100.0
        completed = sum(1 for n in self.nodes if n.status == TaskStatus.COMPLETED)
        return (completed / len(self.nodes)) * 100
    
    def to_react_flow(self) -> Dict[str, Any]:
        """
        Convert to React Flow format for frontend visualization.
        
        Returns:
            {
                "nodes": [{"id", "type", "position", "data"}],
                "edges": [{"id", "source", "target", "animated"}]
            }
        """
        # Compute layers for positioning
        layers = self._compute_layers()
        
        nodes = []
        edges = []
        
        # Agent to position mapping for horizontal spread
        agents_per_layer: Dict[int, int] = {}
        
        for node in self.nodes:
            layer = layers.get(node.id, 0)
            
            # Calculate horizontal position
            if layer not in agents_per_layer:
                agents_per_layer[layer] = 0
            col = agents_per_layer[layer]
            agents_per_layer[layer] += 1
            
            nodes.append({
                "id": node.id,
                "type": "agent",
                "position": {
                    "x": 100 + col * 200,
                    "y": 80 + layer * 160,
                },
                "data": {
                    "agentId": node.agent,
                    "status": node.status.value,
                    "currentAction": node.instruction[:50] + ("..." if len(node.instruction) > 50 else ""),
                    "priority": node.priority.value,
                }
            })
            
            # Create edges for dependencies
            for dep_id in node.dependencies:
                edges.append({
                    "id": f"e-{dep_id}-{node.id}",
                    "source": dep_id,
                    "target": node.id,
                    "animated": node.status == TaskStatus.RUNNING,
                    "style": {
                        "stroke": "#6366f1" if node.status == TaskStatus.RUNNING else "#475569"
                    }
                })
        
        return {"nodes": nodes, "edges": edges}
    
    def _compute_layers(self) -> Dict[str, int]:
        """
        Compute topological layers for visualization.
        Layer 0 = nodes with no dependencies.
        """
        layers = {}
        remaining = set(n.id for n in self.nodes)
        current_layer = 0
        
        # Build dependency map
        node_deps = {n.id: set(n.dependencies) for n in self.nodes}
        
        while remaining:
            # Find nodes with all dependencies resolved
            layer_nodes = []
            for node_id in remaining:
                if all(d not in remaining for d in node_deps.get(node_id, [])):
                    layer_nodes.append(node_id)
            
            if not layer_nodes:
                # Cycle detected or error - assign remaining to current layer
                for node_id in remaining:
                    layers[node_id] = current_layer
                break
            
            for node_id in layer_nodes:
                layers[node_id] = current_layer
                remaining.remove(node_id)
            
            current_layer += 1
        
        return layers
    
    def to_json(self) -> str:
        """Serialize to JSON string"""
        return self.model_dump_json(indent=2)
    
    @classmethod
    def from_json(cls, json_str: str) -> "WorkflowPlan":
        """Deserialize from JSON string"""
        return cls.model_validate_json(json_str)


class PlanGenerationRequest(BaseModel):
    """Request to generate a workflow plan"""
    user_request: str = Field(..., description="The user's original request")
    context: Optional[Dict[str, Any]] = Field(default=None, description="Additional context")
    available_agents: Optional[List[str]] = Field(default=None, description="Limit to specific agents")


class PlanGenerationResponse(BaseModel):
    """Response with generated workflow plan"""
    plan: WorkflowPlan
    reasoning: str = Field(..., description="Why this plan was generated")
