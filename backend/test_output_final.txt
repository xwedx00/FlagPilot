============================= test session starts ==============================
platform linux -- Python 3.11.14, pytest-8.4.2, pluggy-1.6.0
rootdir: /app
plugins: asyncio-1.1.1, anyio-4.12.0
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 5 items

tests/metagpt/test_context.py .E                                         [ 40%]
tests/metagpt/test_planner.py .                                          [ 60%]
tests/metagpt/test_registry.py FF                                        [100%]

==================================== ERRORS ====================================
_____________ ERROR at setup of test_team_environment_propagation ______________
file /app/tests/metagpt/test_context.py, line 30
  @pytest.mark.asyncio
  async def test_team_environment_propagation(mock_user, mocker):
      """
      Test that FlagPilotTeam propagates context (user_id) to agents via Environment.
      """
      # 1. Initialize Team
      team = FlagPilotTeam(agents=["test-agent"])

      # 2. Mock the Orchestrator and Agent specifically for this test
      # We want to ensure environment context is set when agents are hired/run

      # Mock orchestrator.analyze to return a simple plan
      if hasattr(team, 'orchestrator'):
           mocker.patch.object(team.orchestrator, 'analyze', return_value="Plan: Do it")

      # Mock _run_agent to spy on the agent's context
      spy_run_agent = mocker.spy(team, '_run_agent')

      # Mock registry to return MockRole
      mocker.patch('agents.registry.registry.get_agent_class', return_value=MockRole)
      team.active_agents["test-agent"] = MockRole # Force inject

      # 3. Simulate Run with Context
      user_context = {"id": mock_user.id, "custom_key": "custom_val"}

      # We mock _identify_relevant_agents to select our test agent
      mocker.patch.object(team, '_identify_relevant_agents', return_value=["test-agent"])

      await team.run("Task", context=user_context)

      # 4. Verification
      # Check if _run_agent was called
      assert spy_run_agent.call_count == 1

      # Get the agent instance passed to _run_agent
      # args: (self, agent_id, agent, task, context)
      call_args = spy_run_agent.call_args[0]
      agent_instance = call_args[2]

      # Verify the environment context was updated
      # Logic in team.py:
      # if self.env:
      #    for k, v in context.items():
      #        self.env.context.kwargs.set(k, v)

      assert team.env.context.kwargs.get("id") == mock_user.id
      assert team.env.context.kwargs.get("custom_key") == "custom_val"
E       fixture 'mocker' not found
>       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, authenticated_context, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, context, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, init_config, mock_llm, mock_rag, mock_user, monkeypatch, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/app/tests/metagpt/test_context.py:30
=================================== FAILURES ===================================
_____________________________ test_auto_discovery ______________________________

setup_registry = ToolRegistry(tools={}, tools_by_tags=defaultdict(<class 'dict'>, {}))

    def test_auto_discovery(setup_registry):
        """Test that the registry finds tools in the default directory."""
        tools = setup_registry.get_all_tools()
    
        # Check if calculator tool exists
>       assert "calculator_add" in tools
E       AssertionError: assert 'calculator_add' in {}

tests/metagpt/test_registry.py:25: AssertionError
____________________________ test_schema_generation ____________________________

setup_registry = ToolRegistry(tools={}, tools_by_tags=defaultdict(<class 'dict'>, {}))

    def test_schema_generation(setup_registry):
        """Test that ToolSchema is correctly generated from AST."""
        tool = setup_registry.get_tool("calculator_add")
    
>       schema = tool.schemas
                 ^^^^^^^^^^^^
E       AttributeError: 'NoneType' object has no attribute 'schemas'

tests/metagpt/test_registry.py:35: AttributeError
=============================== warnings summary ===============================
../usr/local/lib/python3.11/site-packages/pydantic/_internal/_config.py:272
../usr/local/lib/python3.11/site-packages/pydantic/_internal/_config.py:272
  /usr/local/lib/python3.11/site-packages/pydantic/_internal/_config.py:272: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.6/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/metagpt/test_registry.py::test_auto_discovery - AssertionError: ...
FAILED tests/metagpt/test_registry.py::test_schema_generation - AttributeErro...
ERROR tests/metagpt/test_context.py::test_team_environment_propagation
=============== 2 failed, 2 passed, 2 warnings, 1 error in 2.29s ===============
